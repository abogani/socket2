/*----- PROTECTED REGION ID(Socket2.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        Socket2.cpp
//
// description : C++ source for the Socket2 class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Socket2 are implemented in this file.
//
// project :     
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author: alessio $
//
// $Revision: 1.26 $
// $Date: 2019-01-10 15:58:04 $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Socket2.h>
#include <Socket2Class.h>

#include <fcntl.h>
#include <sys/ioctl.h>
#include <csignal>
#include <arpa/inet.h>
#include <netinet/tcp.h>

/*----- PROTECTED REGION END -----*/	//	Socket2.cpp

/**
 *  Socket2 class description:
 *    
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  Write         |  write
//  Read          |  read
//  ReadUntil     |  read_until
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  InputLength    |  Tango::DevLong	Scalar
//  OutputLength   |  Tango::DevLong	Scalar
//  Reconnections  |  Tango::DevLong	Scalar
//================================================================

namespace Socket2_ns
{
/*----- PROTECTED REGION ID(Socket2::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Socket2::namespace_starting

//--------------------------------------------------------
/**
 *	Method     : Socket2::Socket2()
 *	Description: Constructors for a Tango device
 *                implementing the classSocket2
 */
//--------------------------------------------------------
Socket2::Socket2(Tango::DeviceClass *cl, std::string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Socket2::constructor_1) ENABLED START -----*/
	reconnections = -1;
	connecting = false;
	init_device();

	/*----- PROTECTED REGION END -----*/	//	Socket2::constructor_1
}
//--------------------------------------------------------
Socket2::Socket2(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(Socket2::constructor_2) ENABLED START -----*/
	reconnections = -1;
	connecting = false;
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::constructor_2
}
//--------------------------------------------------------
Socket2::Socket2(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(Socket2::constructor_3) ENABLED START -----*/
	reconnections = -1;
	connecting = false;
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::constructor_3
}
//--------------------------------------------------------
Socket2::~Socket2()
{
	delete_device();
}

//--------------------------------------------------------
/**
 *	Method     : Socket2::delete_device()
 *	Description: will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Socket2::delete_device()
{
	DEBUG_STREAM << "Socket2::delete_device() " << device_name << std::endl;
	/*----- PROTECTED REGION ID(Socket2::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	close();
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::delete_device
	delete[] attr_InputLength_read;
	delete[] attr_OutputLength_read;
	delete[] attr_Reconnections_read;
}

//--------------------------------------------------------
/**
 *	Method     : Socket2::init_device()
 *	Description: will be called at device initialization.
 */
//--------------------------------------------------------
void Socket2::init_device()
{
	DEBUG_STREAM << "Socket2::init_device() create device " << device_name << std::endl;
	/*----- PROTECTED REGION ID(Socket2::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	init_error.clear();

	/*----- PROTECTED REGION END -----*/	//	Socket2::init_device_before


	//	Get the device properties from database
	get_device_property();

	attr_InputLength_read = new Tango::DevLong[1];
	attr_OutputLength_read = new Tango::DevLong[1];
	attr_Reconnections_read = new Tango::DevLong[1];
	//	No longer if mandatory property not set.
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(Socket2::init_device) ENABLED START -----*/
	
	//	Initialize device
	try
	{
		set_state( Tango::INIT );
		set_status( "Connecting..." );

		if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		{
			ERROR_STREAM << "Fail to ignore SIGPIPE" << endl;
		}

		resolve();
		open();
	}
	catch (Tango::DevFailed &e)
	{
		init_error = "Initialization failed: " + string(e.errors[0].desc);
	}
	catch (...)
	{
		init_error = "Initialization failed: Unknown error";
	}

	if( init_error.empty() )
	{
		check_connection( );
	}

	/*----- PROTECTED REGION END -----*/	//	Socket2::init_device
}

//--------------------------------------------------------
/**
 *	Method     : Socket2::get_device_property()
 *	Description: Read database to initialize property data members.
 */
//--------------------------------------------------------
void Socket2::get_device_property()
{
	/*----- PROTECTED REGION ID(Socket2::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Hostname"));
	dev_prop.push_back(Tango::DbDatum("Port"));
	dev_prop.push_back(Tango::DbDatum("Protocol"));
	dev_prop.push_back(Tango::DbDatum("Timeout"));
	dev_prop.push_back(Tango::DbDatum("IOMultiplexing"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on Socket2Class to get class property
		Tango::DbDatum	def_prop, cl_prop;
		Socket2Class	*ds_class =
			(static_cast<Socket2Class *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Hostname from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  hostname;
		else {
			//	Try to initialize Hostname from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  hostname;
		}
		//	And try to extract Hostname value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  hostname;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Port from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  port;
		else {
			//	Try to initialize Port from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  port;
		}
		//	And try to extract Port value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  port;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Protocol from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  protocol;
		else {
			//	Try to initialize Protocol from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  protocol;
		}
		//	And try to extract Protocol value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  protocol;

		//	Try to initialize Timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
		else {
			//	Try to initialize Timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  timeout;
		}
		//	And try to extract Timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize IOMultiplexing from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  iOMultiplexing;
		else {
			//	Try to initialize IOMultiplexing from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  iOMultiplexing;
		}
		//	And try to extract IOMultiplexing value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  iOMultiplexing;

	}

	/*----- PROTECTED REGION ID(Socket2::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init

	transform(protocol.begin(), protocol.end(), protocol.begin(), ::tolower);
	if (protocol == "udp")
	{
		proto = UDP;
		DEBUG_STREAM << "Using UDP protocol" << endl;
	}
	else
	{
		proto = TCP;
		DEBUG_STREAM << "Using TCP protocol" << endl;
	}

	transform(iOMultiplexing.begin(), iOMultiplexing.end(), iOMultiplexing.begin(), ::tolower);
	if (iOMultiplexing == "sleep")
	{
		multiplexing = SLEEP;
		DEBUG_STREAM << "Using sleep IO multiplexing type" << endl;
	}
	else
	{
		multiplexing = SELECT;
		DEBUG_STREAM << "Using select IO multiplexing type" << endl;
	}

	/*----- PROTECTED REGION END -----*/	//	Socket2::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method     : Socket2::check_mandatory_property()
 *	Description: For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void Socket2::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << std::endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(Socket2::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	Socket2::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method     : Socket2::always_executed_hook()
 *	Description: method always executed before any command is executed
 */
//--------------------------------------------------------
void Socket2::always_executed_hook()
{
	DEBUG_STREAM << "Socket2::always_executed_hook()  " << device_name << std::endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"Socket2::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(Socket2::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests

	if (! init_error.empty())
	{
		set_state(Tango::FAULT);
		set_status(init_error);
	}
	else
	{
		check_connection( );
	}

	/*----- PROTECTED REGION END -----*/	//	Socket2::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method     : Socket2::read_attr_hardware()
 *	Description: Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Socket2::read_attr_hardware(TANGO_UNUSED(std::vector<long> &attr_list))
{
	DEBUG_STREAM << "Socket2::read_attr_hardware(std::vector<long> &attr_list) entering... " << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute InputLength related method
 *
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Socket2::read_InputLength(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Socket2::read_InputLength(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read_InputLength) ENABLED START -----*/
	//	Set the attribute value
	attr_InputLength_read[0] = input_queue_length() + data.size(); 
	attr.set_value(attr_InputLength_read);
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::read_InputLength
}
//--------------------------------------------------------
/**
 *	Read attribute OutputLength related method
 *
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Socket2::read_OutputLength(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Socket2::read_OutputLength(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read_OutputLength) ENABLED START -----*/
	//	Set the attribute value
	attr_OutputLength_read[0] = output_queue_length();
	attr.set_value(attr_OutputLength_read);
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::read_OutputLength
}
//--------------------------------------------------------
/**
 *	Read attribute Reconnections related method
 *
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Socket2::read_Reconnections(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Socket2::read_Reconnections(Tango::Attribute &attr) entering... " << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read_Reconnections) ENABLED START -----*/
	//	Set the attribute value
	attr_Reconnections_read[0] = reconnections;
	attr.set_value(attr_Reconnections_read);
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::read_Reconnections
}

//--------------------------------------------------------
/**
 *	Method     : Socket2::add_dynamic_attributes()
 *	Description: Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Socket2::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Socket2::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Write related method
 *
 *
 *	@param argin
 */
//--------------------------------------------------------
void Socket2::write(const Tango::DevVarCharArray *argin)
{
	DEBUG_STREAM << "Socket2::Write()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(Socket2::write) ENABLED START -----*/
	check_init();
	
	timeval tout;
	tout.tv_sec = timeout / 1000;
	tout.tv_usec = timeout % 1000 * 1000;
	if ( ! timerisset( &tout ) )
	{
		Tango::Except::throw_exception( "",
				"Invalid timeout",
				"Socket2::write()");
	}

	char *argin_data = new char[ argin->length() ];
	for( unsigned int i=0; i<argin->length(); ++i )
	{
		argin_data[i] = (*argin)[i];
	}

	int bytes_total = 0, bytes_to_write = argin->length();
	while (bytes_total != bytes_to_write &&  wait_for( WRITE, &tout ) )
	{
		int bytes_written;
		bytes_written = proto == UDP? sendto(fd, argin_data + bytes_total,
				bytes_to_write - bytes_total, 0,
				(struct sockaddr*) &sa, sa_len) : 
			::write(fd, argin_data + bytes_total, bytes_to_write - bytes_total);
		if (bytes_written < 0)
		{
			DEBUG_STREAM << strerror( errno ) << " (" << errno << ")" << endl;
			if( errno == EINTR )
			{
				continue;
			}

			if( errno == ECONNREFUSED || errno == EHOSTUNREACH)
			{
				delete argin_data;

				string error_mesg = "Connection refused";

				close();
				open();
				DEBUG_STREAM << error_mesg << endl;
				set_state( Tango::FAULT );
				set_status( error_mesg );

				Tango::Except::throw_exception( "",
						error_mesg,
						"Socket2::write()");
			}

			ERROR_STREAM << "write() error not handled:" << endl;
			assert( false );
		}
		else if( bytes_written == 0 )
		{
			assert( false );
		}
		else /* bytes_written > 0 */
		{
			bytes_total += bytes_written;
		}
	}
	delete argin_data;
	
	timeval time_to_wait;
	time_to_wait.tv_sec = 0;
	time_to_wait.tv_usec = 1000;

	while ( output_queue_length() )
	{
		timeval newtimeout;
		timersub( &tout, &time_to_wait, &newtimeout );
		if( newtimeout.tv_sec >= 0 && newtimeout.tv_usec >= 0 )
		{
			sleep( time_to_wait.tv_sec );
			usleep( time_to_wait.tv_usec );

			tout = newtimeout;
			timeradd( &time_to_wait, &time_to_wait, &time_to_wait );
		}
		else
		{
			sleep( tout.tv_sec );
			usleep( tout.tv_usec );
			timerclear( &tout );
			break;
		}
	}

	if( (bytes_total - output_queue_length()) != bytes_to_write )
	{
		string error_mesg = "Unable to send request to device";

		close();
		open();
		DEBUG_STREAM << error_mesg << endl;
		set_state( Tango::FAULT );
		set_status( error_mesg );

		Tango::Except::throw_exception( "",
				error_mesg,
				"Socket2::write()");
	}

	/*----- PROTECTED REGION END -----*/	//	Socket2::write
}
//--------------------------------------------------------
/**
 *	Command Read related method
 *
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Socket2::read(Tango::DevLong argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Socket2::Read()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read) ENABLED START -----*/
	check_init();

	timeval tout;
	tout.tv_sec = timeout / 1000;
	tout.tv_usec = timeout % 1000 * 1000;
	if ( ! timerisset( &tout ) )
	{
		Tango::Except::throw_exception( "",
				"Invalid timeout",
				"Socket2::read()");
	}

	if (argin < 0)
	{
		Tango::Except::throw_exception("",
				"Input has to be in positive range",
				"Socket2::read()");
	}

	while( (size_t)argin > data.size() )
	{
		if ( ! wait_for( READ, &tout ) )
		{
			string mesg( "No response from device" );
			DEBUG_STREAM << mesg << endl;
			Tango::Except::throw_exception("",
					mesg, "Socket2::read()");
		}
	}

	argout = new Tango::DevVarCharArray();
	argout->length(argin);
	for( int i=0; i<argin; ++i )
	{
		(*argout)[i] = data[i];
	}
	data.erase( data.begin(), data.begin() + argin );

	/*----- PROTECTED REGION END -----*/	//	Socket2::read
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadUntil related method
 *
 *
 *	@param argin
 *	@returns
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Socket2::read_until(const Tango::DevVarCharArray *argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Socket2::ReadUntil()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(Socket2::read_until) ENABLED START -----*/
	check_init();

	timeval tout;
	tout.tv_sec = timeout / 1000;
	tout.tv_usec = timeout % 1000 * 1000;
	if ( ! timerisset( &tout ) )
	{
		Tango::Except::throw_exception( "",
				"Invalid timeout",
				"Socket2::read_until()");
	}

	if (argin->length() != 1)
	{
		Tango::Except::throw_exception("",
				"Delimiter has to be one byte length",
				"Socket2::read_until()");
	}

	char delim = (*argin)[0];
	bool found = false;
	size_t pos;

	while( ! found )
	{
		for( pos = 0; pos < data.size(); ++pos )
		{
			if (memcmp(&data[pos], &delim, 1) == 0)
			{
				found = true;
				break;
			}
		}
		if ( ! found && ! wait_for( READ, &tout ) )
		{
			string mesg( "No response from device" );
			DEBUG_STREAM << mesg << endl;
			Tango::Except::throw_exception("",
					mesg, "Socket2::read_until()");
		}
	}


	argout = new Tango::DevVarCharArray();
	argout->length( pos+1 );
	for( size_t i = 0; i < pos + 1; ++i )
	{
		(*argout)[i] = data[i];
	}
	data.erase( data.begin(), data.begin() + pos + 1 );

	/*----- PROTECTED REGION END -----*/	//	Socket2::read_until
	return argout;
}
//--------------------------------------------------------
/**
 *	Method     : Socket2::add_dynamic_commands()
 *	Description: Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void Socket2::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(Socket2::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	Socket2::add_dynamic_commands
}

/*----- PROTECTED REGION ID(Socket2::namespace_ending) ENABLED START -----*/

//	Additional Methods
void Socket2::check_init()
{
	if (! init_error.empty() )
	{
		DEBUG_STREAM << init_error << endl;
		Tango::Except::throw_exception( "",
				init_error.c_str(),
				"Socket2::check_init()");
	}
}

void Socket2::open()
{
	DEBUG_STREAM << "Creating the file descriptor..." << endl;

	if ((fd = socket(PF_INET, proto == UDP? SOCK_DGRAM:SOCK_STREAM, 0)) == -1)
	{
		string error_mesg = "Socket creation failed: "
			+ string(strerror( errno ));
		ERROR_STREAM << error_mesg << endl;
		assert( false);
		Tango::Except::throw_exception( "",
				error_mesg,
				"Socket2::open()");
	}

	if (proto == TCP) {
		int flag = 1;
		if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(flag)) == -1)
		{
			::close( fd );
	
			string error_mesg = "Disabling Nagle failed: "
				+ string(strerror( errno ));
			ERROR_STREAM << error_mesg << endl;
			assert( false);
			Tango::Except::throw_exception( "",
					error_mesg,
					"Socket2::open()");
		}

		flag = 1;
		if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&flag, sizeof(flag)) == -1)
		{
			::close( fd );
	
			string error_mesg = "Enabling reuseaddr flag failed: "
				+ string(strerror( errno ));
			ERROR_STREAM << error_mesg << endl;
			assert( false);
			Tango::Except::throw_exception( "",
					error_mesg,
					"Socket2::open()");
		}
	}

	int flags = fcntl(fd, F_GETFL, 0);
	if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
	{
		::close( fd );

		string error_mesg = "Enabling O_NONBLOCK failed: "
			+ string(strerror( errno ));
		ERROR_STREAM << error_mesg << endl;
		assert( false);
		Tango::Except::throw_exception( "",
				error_mesg,
				"Socket2::open()");
	}

	DEBUG_STREAM << "Connecting..." << endl;
	::connect(fd, (sockaddr*)&sa, sizeof(sockaddr));

	connecting = true;
}

void Socket2::close()
{
	DEBUG_STREAM << "Closing the file descriptor..." << endl;

	connecting = false;

	int input_len = input_queue_length() + data.size();
	int output_len = output_queue_length();

	if( input_len + output_len)
	{
		WARN_STREAM << " Bytes dropped: " << input_len << " input, "
			<< output_len << " output" << endl;
	}

	if (::close(fd) == -1)
	{
		ERROR_STREAM << "Error closing file descriptor: "
			<< strerror(errno) << endl;
	}

	data.clear();

	DEBUG_STREAM << "File descriptor closed" << endl;
}

int Socket2::input_queue_length()
{
	int len;
	if (ioctl(fd, FIONREAD, &len) == -1)
	{
		len = 0;
	}
	return len;
}

int Socket2::output_queue_length()
{
	int len;
	if (ioctl(fd, TIOCOUTQ, &len) == -1)
	{
		len = 0;
	}
	return len;
}

void Socket2::resolve()
{
	DEBUG_STREAM << "Resolving " << hostname << "... " << endl;
	char ipstr[INET6_ADDRSTRLEN];

	sa_len = sizeof(sa);
	memset(&sa, 0, sa_len);

	addrinfo hints;
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	addrinfo *res, *p;

	if (inet_pton(AF_INET, hostname.c_str(), &(sa.sin_addr)) > 0)
	{
		sa.sin_family = AF_INET;
		sa.sin_port = htons(port);
	}
	else if (getaddrinfo(hostname.c_str(), NULL, &hints, &res) == 0)
	{
		for (p=res; p!=NULL; p=p->ai_next)
		{
			if (p->ai_family == AF_INET)
			{
				inet_ntop(p->ai_family,
						&(((sockaddr_in *)p->ai_addr)->sin_addr),
						ipstr, sizeof ipstr);
				sa.sin_addr = ((sockaddr_in *)p->ai_addr)->sin_addr;
				sa.sin_family = ((sockaddr_in *)p->ai_addr)->sin_family;
				sa.sin_port = htons(port);
			}
		}
		freeaddrinfo(res);
	}
	else
	{
		string error_mesg = "Name resolution failed";
		ERROR_STREAM << error_mesg << endl;
		Tango::Except::throw_exception( "",
				error_mesg,
				"Socket2::resolve()");
	}
}

void Socket2::check_connection( )
{
	int so_error;
	socklen_t len = sizeof so_error;
	getsockopt(fd, SOL_SOCKET, SO_ERROR, &so_error, &len);
#ifndef NDEBUG
	DEBUG_STREAM << "getsockopt(): " << strerror( so_error ) << " (" << so_error << ")" << endl;
#endif

	bool do_reconnect = false;
	string error_mesg;
	switch( so_error )
	{
		case EHOSTUNREACH:
			error_mesg = "No route to host";
			do_reconnect = true;
			break;
		case ECONNREFUSED:
			error_mesg = "Connection refused";
			do_reconnect = true;
			break;
		case EPIPE:
			error_mesg = "Broken pipe";
			do_reconnect = true;
			break;
		case ETIMEDOUT:
			error_mesg = "Connection timed out";
			do_reconnect = true;
			break;
		case ECONNRESET:
			error_mesg = "Connection reset by peer";
			do_reconnect = true;
			break;
		case EISCONN:
		case EALREADY:
		case EINPROGRESS:
		case EADDRNOTAVAIL:
		case EAFNOSUPPORT:
		case EBADF:
		case EINTR:
		case ENOTSOCK:
		case EPROTOTYPE:
		case EIO:
		case ELOOP:
		case ENAMETOOLONG:
		case ENOENT:
		case ENOTDIR:
		default:
			ERROR_STREAM << "Socket error " << so_error
				<< " not handled!" << endl;
			abort( );
			break;
		case 0 /* SUCCESS */:
			break;
	}

	if( do_reconnect )
	{
		close();
		open();
		DEBUG_STREAM << error_mesg << endl;
		set_state( Tango::FAULT );
		set_status( error_mesg );
	}
	else
	{
		timeval tv;
		timerclear( &tv );
		if( wait_for( WRITE, &tv ) )
		{
			if( connecting )
			{
				reconnections++;
				connecting = false;
			}

			set_state( Tango::ON );
			set_status( "Connected" );
		}
	}
}

bool Socket2::read(timeval *tv)
{
	int bytes_total = 0, bytes_to_read = input_queue_length();
	do
	{
		int len = (bytes_to_read - bytes_total) > BUFFER_SIZE?
			BUFFER_SIZE : (bytes_to_read - bytes_total);

		int bytes_readed = proto == UDP? 
			recvfrom(fd, buffer, len, 0, (struct sockaddr*) &sa, &sa_len) : 
			::read(fd, buffer, len);

		if( bytes_readed < 0 )
		{
			DEBUG_STREAM << strerror( errno ) << " (" << errno << ")" << endl;
			if( errno == EINTR)
			{
				continue;
			}
		}
		else if( bytes_readed == 0 )
		{
			close();
			open();

			DEBUG_STREAM << "Server shutting down" << endl;
			set_state(Tango::FAULT);
			set_status("Server shutting down");

			sleep( tv->tv_sec );
			usleep( tv->tv_usec );
			timerclear( tv );

			return false;
		}
		else /* bytes_readed > 0 */
		{
			data.insert(data.end(), &buffer[0], &buffer[bytes_readed]);
			bytes_total += bytes_readed;
		}
	}
	while (bytes_total != bytes_to_read);

	return true;
}

bool Socket2::wait_for( event_type et, timeval *tv )
{
	switch(multiplexing) {
		case SLEEP:
			return wait_for_with_sleep(et, tv);
		default:
			return wait_for_with_select(et, tv);
	}
}

bool Socket2::wait_for_with_sleep( event_type et, timeval *tv )
{
	struct timeval sleep_time;
	sleep_time.tv_sec = 0;
	sleep_time.tv_usec = 10000; /* 10 ms */

	do {
		switch( et )
		{
			case WRITE:
				if( output_queue_length() == 0 )
				{
#ifndef NDEBUG
					DEBUG_STREAM << "Ready to write" << endl;
#endif
					return true;
				}
				break;
			case READ:
				if( input_queue_length() != 0 )
				{
#ifndef NDEBUG
					DEBUG_STREAM << "Ready to read" << endl;
#endif
					return read(tv);
				}
				break;
		}

		int usleep_ret = usleep(sleep_time.tv_usec);
#ifndef NDEBUG
		DEBUG_STREAM << "usleep(): " << usleep_ret << endl;
#else
		(void)usleep_ret;
#endif
		timersub(tv, &sleep_time, tv);
	} while (timerisset(tv));

	return false;
}

bool Socket2::wait_for_with_select( event_type et, timeval *tv )
{
	FD_ZERO(&errorfds);
	FD_ZERO(&readfds);
	FD_ZERO(&writefds);

	FD_SET(fd, &errorfds);

	switch( et )
	{
		case WRITE:
			FD_SET(fd, &writefds);
			break;
		case READ:
			FD_SET(fd, &readfds);
			break;
	}
	int select_ret = select( fd + 1, &readfds, &writefds, &errorfds, tv );

#ifndef NDEBUG
	DEBUG_STREAM << "select(): " << select_ret << endl;
#endif

	if( select_ret == -1 )
	{
		ERROR_STREAM << "Select() error " << select_ret << " not handled:" 
			<< strerror( errno ) << endl;
		assert( false );
	}
	else if( select_ret == 0 )
	{
		return false;
	}

	if (FD_ISSET(fd, &errorfds))
	{
		ERROR_STREAM << "Select() error event not handled!" << endl;
		assert( false );
	}

	if (FD_ISSET(fd, &writefds))
	{
#ifndef NDEBUG
		DEBUG_STREAM << "Ready to write" << endl;
#endif
	}

	if (FD_ISSET(fd, &readfds))
	{
#ifndef NDEBUG
		DEBUG_STREAM << "Ready to read" << endl;
#endif
		return read(tv);
	}
	
	return true;
}

/*----- PROTECTED REGION END -----*/	//	Socket2::namespace_ending
} //	namespace
